#!/usr/bin/env python
# stix is a cable knitting pattern visualiser that uses termbox

import termbox

#max_w = 100
#max_h = 50
filename = "test.stix"

   


def draw_screen(tb, pattern, style, softline, hardline):
    cols = tb.width()
    rows = tb.height()
    #NOTE here we pretend that scrolling is not a thing
    # possibly move shit from top-down to bottom-up array
    
    # draw all the things
    for i, r in enumerate(pattern): #TODO find out if r is needed
        number = i + 1
        if softline == number and hardline == number:
            draw_line(tb, pattern, number, style, 'double')
        elif softline == number:
            draw_line(tb, pattern, number, style, 'soft')
        elif hardline == number:
            draw_line(tb, pattern, number, style, 'hard')
        else:
            draw_line(tb, pattern, number, style)

    tb.present()


def y_row(total, p_row):
    return total - p_row - 1


def draw_line(tb, pattern, line, style, stylename='default'):
    rows = tb.height()
    cols = tb.width()
    
    if len(pattern) > y_row(rows, line):
        for i, char in enumerate(pattern[y_row(rows, line)]):
            # apply style
            (fg, bg) = style[stylename]
            # draw correct char in the right place
            tb.change_cell(i, y_row(rows, line), ord(char), fg, bg)
    else:
        for pos in range(cols):
            # apply style
            (fg, bg) = style[stylename]
            # draw emptiness
            tb.change_cell(pos, y_row(rows, line), ord(' '), fg, bg)
            
        

def move_line(tb, pattern, style, hardline, old_line, up_lines):
    softline = old_line + up_lines
    if hardline == old_line:
        draw_line(tb, pattern, old_line, style, 'hard')
        draw_line(tb, pattern, softline, style, 'soft')
    elif hardline == softline:
        draw_line(tb, pattern, old_line, style, 'default')
        draw_line(tb, pattern, softline, style, 'double')
    else:
        draw_line(tb, pattern, old_line, style, 'default')
        draw_line(tb, pattern, softline, style, 'soft')
    print_msg(tb, 'softline: {} -> {}'.format(old_line, softline))
    tb.present()
    return softline


def reset_line(tb, pattern, style, old_line, new_line):
    rows = tb.height()
    hardline = rows - new_line - 1
    draw_line(tb, pattern, old_line, style, 'soft')
    draw_line(tb, pattern, hardline, style, 'hard')
    print_msg(tb, 'hardline reset: {} -> {}'.format(old_line, hardline))
    tb.present()
    return hardline
    

def print_msg(tb, msg):
    bottom = tb.height() - 1
    fg = termbox.WHITE
    bg = termbox.RED
    for i, char in enumerate(msg):
        tb.change_cell(i, bottom, ord(char), fg, bg)
    tb.present()


def prompt_quit(tb):
    # Here should be some poll event for asking y/N
    return True


def boxtest(tb):
    rows = tb.height()
    cols = tb.width()
    print_msg(tb, 'we get signal, height {} width {}'.format(rows, cols))

def main():
    lines = [line.rstrip('\n') for line in open(filename)]

    hardline = 1
    try:
        hardline = int(lines[0])
    except ValueError:
        hardline = 1
    softline = hardline

    with termbox.Termbox() as tb:
        style = {
                'default': (termbox.WHITE, termbox.DEFAULT),
                'soft': (termbox.WHITE | termbox.BOLD, termbox.BLACK),
                'hard': (termbox.BLACK, termbox.WHITE),
                'double': (termbox.BLACK | termbox.BOLD, termbox.WHITE)
                }

        tb.clear()
        print_msg(tb, 'initline: {}'.format(softline))
        
        # read the rest to matrix array thingy
        pattern = lines[1:]

        draw_screen(tb, pattern, style, softline, hardline)
        #boxtest(tb)
        counter = 0
        while True:
            current_event = tb.poll_event()
            (evtype, char, key, mod, w, h, mx, my) = current_event
            if evtype == termbox.EVENT_RESIZE:
                draw_screen(tb, pattern, style, softline, hardline)
            elif evtype == termbox.EVENT_KEY:
                if key == termbox.KEY_ARROW_UP:
                    print_msg(tb, 'up and away! --{}'.format(counter))
                    softline = move_line(tb, pattern, style, hardline, softline, 1)
                elif key == termbox.KEY_ARROW_DOWN:
                    print_msg(tb, 'dooown --{}'.format(counter))
                    softline = move_line(tb, pattern, style, hardline, softline, -1)
                elif key == termbox.KEY_ENTER:
                    print_msg(tb, 'OK --{}'.format(counter))
                    hardline = reset_line(tb, pattern, style, hardline, softline)
                elif key == termbox.KEY_ESC:
                    if prompt_quit(tb):
                        break
            counter +=1
#    print('trying to start')
#    with Stixbox() as ui:
#        ui.running = True
#        print(ui.running)
#        while ui.running:
#            current_event = ui.poll_event()
#            while current_event:
#                (type, ch, key, mod, w, h, x, y) = current_event
#                if type == tb.EVENT_RESIZE:
#                    ui.draw_screen()
#                if type == tb.EVENT_KEY:
#                    if key == tb.KEY_ARROW_UP:
#                        ui.move_line(1)
#                    elif key == tb.KEY_ARROW_DOWN:
#                        ui.move_line(-1)
#                    elif key == tb.KEY_ENTER:
#                        ui.reset_line(y)
#                    elif key == tb.KEY_ESCAPE:
#                        ui.prompt_quit()
#                current_event = ui.poll_event()
#

if __name__ == '__main__':
    main()


#def f(x):
#    return {
#        'a': 1,
#        'b': 2,
#    }.get(x, 9)    # 9 is default if x not found

